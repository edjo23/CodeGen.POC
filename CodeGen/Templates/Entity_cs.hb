/*
 * This file is automatically generated; any changes will be lost. 
 */

#nullable enable

{{#with EntityClass}}
{{#each Usings}}
using {{this}};
{{/each}}

namespace {{Namespace}}
{
    {{#if NewtonsoftJsonSerialization}}[JsonObject(MemberSerialization = MemberSerialization.OptIn)]{{/if}}
    public{{#if Abstract}} abstract{{/if}}{{#if Partial}} partial{{/if}} class {{Name}}{{#each Implements}}{{#if @first}} : {{/if}}{{{this}}}{{#unless @last}}, {{/unless}}{{/each}}
    {
        {{#if HasBeefBaseClass}}
        #region Privates

        {{#Properties}}
        private {{Type}}{{#if Nullable}}?{{/if}} _{{camel Name}};
        {{/Properties}}

        #endregion

        {{/if}}
        #region Properties

        {{#each Properties}}
        {{#if ../NewtonsoftJsonSerialization}}
        [JsonProperty("{{camel Name}}", DefaultValueHandling = DefaultValueHandling.{{#if EmitDefaultValue}}Include{{else}}Ignore{{/if}})]
        {{/if}}
        [Display(Name="{{DisplayName}}")]
        public {{Type}}{{#if Nullable}}?{{/if}} {{Name}}{{#unless ../HasBeefBaseClass}} { get; set; }{{/unless}}
        {{#if ../HasBeefBaseClass}}
        {
            get => _{{camel Name}};
            {{#if IsString}}
            set => SetValue(ref _{{camel Name}}, value, {{#if Immutable}}true{{else}}false{{/if}}, StringTrim.{{StringTrim}}, StringTransform.{{StringTransform}}, nameof({{Name}}));
            {{else}}
            {{#if IsDateTime}}
            set => SetValue(ref _{{camel Name}}, value, {{#if Immutable}}true{{else}}false{{/if}}, DateTimeTransform.DateOnly, nameof({{Name}}));
            {{else}}
            set => SetValue(ref _{{camel Name}}, value, {{#if Immutable}}true{{else}}false{{/if}}, {{#if BubblePropertyChanged}}true{{else}}false{{/if}}, nameof({{Name}}));
            {{/if}}        
            {{/if}}        
        }
        {{/if}}
        {{#unless @last}}
        
        {{/unless}}
        {{/each}}

        #endregion
        {{#if HasBeefBaseClass}}
        {{#if EntityProperties.Count}}

        #region IChangeTracking

        public override void AcceptChanges()
        {
            {{#each EntityProperties}}
            {{Name}}?.AcceptChanges();
            {{/each}}
            base.AcceptChanges();
        }

        #endregion
        {{/if}}
        {{#if UniqueKeys}}

        #region UniqueKey

        public override bool HasUniqueKey => true;

        public override string[] UniqueKeyProperties => new string[] { {{#each UniqueKeys}}nameof({{Name}}){{#unless @last}}, {{/unless}}{{/each}} };

        #endregion
        {{/if}}

        #region IsEquitable
        
        public override bool Equals(object? obj)
        {
            if (obj == null || !(obj is {{Name}} val))
                return false;

            return Equals(val);
        }

        public bool Equals({{Name}}? value)
        {
            if (((object)value!) == ((object)this))
                return true;
            else if (((object)value!) == null)
                return false;

            return base.Equals((object)value)
                {{#each Properties}}
                && Equals({{Name}}, value.{{Name}}){{#if @last}};{{/if}}
                {{/each}}
        }

        public override int GetHashCode()
        {
            var hash = new HashCode();

            {{#each Properties}}
            hash.Add({{Name}});
            {{/each}}

            return base.GetHashCode() ^ hash.ToHashCode();
        }

        #endregion

        #region ICopyFrom

        public override void CopyFrom(object from)
        {
            var fval = ValidateCopyFromType<{{Name}}>(from);
            CopyFrom(fval);
        }

        public void CopyFrom({{Name}} from)
        {
            CopyFrom(({{Implements.[0]}})from);
            {{#each Properties}}
            {{Name}} = from.{{Name}};
            {{/each}}
        }

        #endregion
        {{#unless Abstract}}

        #region ICloneable

        public override object Clone()
        {
            var clone = new {{Name}}();
            clone.CopyFrom(this);
            return clone;
        }        

        #endregion
        {{/unless}}
        
        #region ICleanUp

        public override void CleanUp()
        {
            base.CleanUp();
            {{#each CleanProperties}}
            {{Name}} = Cleaner.Clean({{Name}}{{#if IsString}}, StringTrim.{{StringTrim}}, StringTransform.{{StringTransform}}{{/if}}{{#if IsDateTime}}, DateTimeTransform.{{DateTimeTransform}}{{/if}});
            {{/each}}
        }

        public override bool IsInitial
        {
            get
            {
              {{#each Properties}}
              {{#if @first}}return {{else}}    && {{/if}}Cleaner.IsInitial({{Name}}){{#if @last}};{{/if}}
              {{/each}}
            }
        }

        #endregion
        {{/if}}
    }
    {{#if CollectionName}}

    public class {{CollectionName}} : {{#each CollectionImplements}}{{{this}}}{{#unless @last}}, {{/unless}}{{/each}}{{#unless CollectionHasBeefBaseClass}} { }{{/unless}}
    {{#if CollectionHasBeefBaseClass}}
    {
        #region Constructors

        public {{CollectionName}}() { }

        public {{CollectionName}}(IEnumerable<{{Name}}> entities) => AddRange(entities);
        
        #endregion

        #region ICloneable
        
        public override object Clone()
        {
            var clone = new {{CollectionName}}();
            foreach ({{Name}} item in this)
            {
                clone.Add(({{Name}})item.Clone());
            }
                
            return clone;
        }
        
        #endregion
        {{#if CollectionResultName}}

        #region Operator

        public static implicit operator {{CollectionName}}({{CollectionResultName}} result) => result?.Result!;

        #endregion
        {{/if}}
    }
    {{#if CollectionResultName}}

    public class {{CollectionResultName}} : EntityCollectionResult<{{CollectionName}}, {{Name}}>
    {
        public {{CollectionResultName}}() { }
        
        public {{CollectionResultName}}(PagingArgs? paging) : base(paging) { }
        
        public {{CollectionResultName}}(IEnumerable<{{Name}}> collection, PagingArgs? paging = null) : base(paging) => Result.AddRange(collection);
        
        public override object Clone()
        {
            var clone = new {{CollectionResultName}}();
            clone.CopyFrom(this);
            return clone;
        }
    }
    {{/if}}
    {{/if}}
    {{/if}}
}

{{/with}}
#nullable restore